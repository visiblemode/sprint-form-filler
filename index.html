<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Sprint Tier Filler</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <!-- Dependency per spec -->
  <script src="lz-string.min.js"></script>
  <!-- Optional fallback if local file missing -->
  <script>
    (function ensureLZ(){
      if (!window.LZString) {
        var s = document.createElement('script');
        s.src = "https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js";
        document.head.appendChild(s);
      }
    })();
  </script>
  <style>
    :root{
      /* Pastels on dark */
      --pastel-red:    rgba(255,107,129,0.28);
      --pastel-yellow: rgba(255,221, 87,0.28);
      --pastel-green:  rgba( 46,204,113,0.28);
      --pastel-teal:   rgba( 26,188,156,0.28);
      --pastel-grey:   rgba(200,200,200,0.28);
      /* Overcap */
      --overcap-fill:  rgba(220, 53, 69, 0.35);
      --overcap-border:#dc3545;
    }

    /* dark theme + no text selection (desktop + mobile) */
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    html, body {
      height: 100%;
      touch-action: manipulation; /* prevents double-tap to zoom while allowing normal taps */
    }
    body {
      margin: 12px;
      font-family: system-ui, sans-serif;
      background: #000;
      color: #eee;
      user-select: none;          /* desktop */
      -webkit-user-select: none;  /* iOS/Safari */
      -ms-user-select: none;
    }

    h2 { margin: 12px 0 6px; font-size: 1rem; color:#fff; }
    .app { display: grid; gap: 16px; }

    .tip { color:#ddd; font-size: 0.95rem; }

    .row { display: grid; gap: 8px; }
    .row-head { display:flex; align-items:baseline; gap:10px; flex-wrap:wrap; }
    .row-head .live { font-weight:600; color:#fff; }
    .row-head .count { font-variant-numeric: tabular-nums; color:#fff; }
    .row-head .count.over { color: #ff6464; } /* only the X goes red */

    .palette, .tier {
      border: 1px dashed #666;   /* 1px borders per request */
      padding: 8px;
      min-height: 64px;
      display: flex;
      flex-wrap: wrap;
      align-items: flex-start;
      gap: 6px;
      position: relative;
      border-radius: 10px;
    }

    /* Tier color assignments */
    #tier-top3 { background: var(--pastel-red); }
    #tier-high { background: var(--pastel-yellow); }
    #tier-mid  { background: var(--pastel-green); }
    #tier-low  { background: var(--pastel-teal); }
    #tier-ni   { background: var(--pastel-grey); }

    /* Overcap: firmer red fill + thicker dashed border */
    .tier.overcap {
      background: var(--overcap-fill) !important;
      border-color: var(--overcap-border);
      border-width: 2px;
      border-style: dashed;
    }

    /* During mobile drag, show a clear target highlight */
    .tier.targeting {
      outline: 2px solid #fff;
      outline-offset: 2px;
    }

    .icon {
      width: 56px; height: 56px;
      border: 1px solid #444;           /* 1px */
      border-radius: 10px;
      overflow: hidden;                  /* ensure corners clip the image */
      background: #111 center/contain no-repeat;
      display: inline-flex; align-items: center; justify-content: center;
      cursor: grab; user-select: none; touch-action: none; position: relative;
    }
    .icon:active { cursor: grabbing; }
    .icon img { width: 100%; height: 100%; object-fit: contain; pointer-events: none; }

    /* Desktop ghost */
    .ghost {
      width: 56px; height: 56px;
      outline: 2px solid #aaa; outline-offset: -2px; border-radius: 10px;
      background: repeating-linear-gradient(45deg,#1c1c1c,#1c1c1c 6px,#151515 6px,#151515 12px);
    }

    /* Mobile tap-to-select affordance */
    .icon.selected {
      border-width: 2px;
      border-color: #fff;
      box-shadow: 0 0 0 3px rgba(255,255,255,0.15);
      animation: soft-glow 1.2s ease-in-out infinite alternate;
    }
    @keyframes soft-glow {
      from { box-shadow: 0 0 0 3px rgba(255,255,255,0.12); }
      to   { box-shadow: 0 0 12px 3px rgba(255,255,255,0.25); }
    }

    .controls { display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
    button {
      padding: 8px 12px;
      background:#111; color:#eee;
      border:1px solid #666; border-radius:8px;
    }
    button:hover { background:#181818; }
    .small { font-size: 0.9rem; color:#bbb; }

    /* Mobile move controls (injected under active tier) */
    .mobile-controls {
      display:flex; gap:8px; margin-top:6px;
    }
    .mobile-controls.hidden { display:none; }
  </style>
</head>
<body>
  <div class="app">
    <!-- Top tooltip stays at top -->
    <div class="tip">
      Drag items into tiers. Over-cap rows turn light red. Palette items are treated as Not Interested (not submitted).
    </div>

    <!-- Tiers -->
    <section class="row">
      <div class="row-head">
        <h2>Top 3 (<span class="live">Current: <span id="cnt-top3" class="count">0</span>/3</span>)</h2>
      </div>
      <div id="tier-top3" class="tier" data-tier="top3" data-max="3" aria-label="Top 3"></div>
    </section>

    <section class="row">
      <div class="row-head">
        <h2>High (<span class="live">Current: <span id="cnt-high" class="count">0</span>/5</span>)</h2>
      </div>
      <div id="tier-high" class="tier" data-tier="high" data-max="5" aria-label="High"></div>
    </section>

    <section class="row">
      <div class="row-head">
        <h2>Mid (<span class="live">Current: <span id="cnt-mid" class="count">0</span>/10</span>)</h2>
      </div>
      <div id="tier-mid" class="tier" data-tier="mid" data-max="10" aria-label="Mid"></div>
    </section>

    <section class="row">
      <div class="row-head">
        <h2>Low (<span class="live">Current: <span id="cnt-low" class="count">0</span>/15</span>)</h2>
      </div>
      <div id="tier-low" class="tier" data-tier="low" data-max="15" aria-label="Low"></div>
    </section>

    <section class="row">
      <div class="row-head">
        <h2>Not Interested</h2>
      </div>
      <div id="tier-ni" class="tier" data-tier="ni" aria-label="Not Interested"></div>
    </section>

    <!-- Controls + Palette below tiers -->
    <section class="row">
      <div class="controls">
        <button id="fillBtn">Fill Google Form</button>
        <button id="resetBtn" title="Move all items back to the palette">Reset</button>
        <span class="small">Palette is below â€” items left here are not submitted.</span>
      </div>
      <div class="row-head">
        <h2>Palette</h2>
      </div>
      <div id="palette" class="palette" data-tier="palette" aria-label="Palette"></div>
    </section>
  </div>

  <script>
    // ---------------------------
    // Helpers
    // ---------------------------
    function alertWithContact(msg) {
      alert(msg + "\n\nPlease notify @dovemail on Discord about this error");
    }
    function alertSimple(msg) { alert(msg); } // for overfill only

    function getParam(name) {
      const fromHash = new URLSearchParams((location.hash || "").replace(/^#/, ""));
      if (fromHash.has(name)) return fromHash.get(name);
      const fromQuery = new URLSearchParams(location.search);
      if (fromQuery.has(name)) return fromQuery.get(name);
      return null;
    }

    function convertToIconData(parsed) {
      if (!Array.isArray(parsed.pokemon)) throw new Error("`pokemon` must be an array");
      return parsed.pokemon.map(item => {
        if (!Array.isArray(item) || item.length < 3) {
          throw new Error("Each pokemon item must be [displayName, entryId, imageFile]");
        }
        const [displayName, entryId, imageFile] = item;
        const imgUrl = `https://www.serebii.net/pokemonsleep/pokemon/icon/${imageFile}`;
        return { name: displayName, entryId, imgUrl };
      });
    }

    function findInsertionPoint(container, clientX) {
      const children = Array.from(container.querySelectorAll('.icon'));
      let closest = null, closestOffset = Number.POSITIVE_INFINITY;
      for (const child of children) {
        const rect = child.getBoundingClientRect();
        const mid = rect.left + rect.width / 2;
        const offset = clientX - mid;
        if (offset < 0 && Math.abs(offset) < closestOffset) {
          closestOffset = Math.abs(offset);
          closest = child;
        }
      }
      return closest; // null => append
    }

    function tierElements() {
      return {
        palette: document.getElementById('palette'),
        top3: document.getElementById('tier-top3'),
        high: document.getElementById('tier-high'),
        mid: document.getElementById('tier-mid'),
        low: document.getElementById('tier-low'),
        ni: document.getElementById('tier-ni'),
      };
    }
    function headerSpans() {
      return {
        top3: document.getElementById('cnt-top3'),
        high: document.getElementById('cnt-high'),
        mid:  document.getElementById('cnt-mid'),
        low:  document.getElementById('cnt-low'),
      };
    }

    function updateTierHeadersAndCaps() {
      const tiers = document.querySelectorAll('.tier');
      const hdr = headerSpans();
      tiers.forEach(tier => {
        const cap = tier.dataset.max ? parseInt(tier.dataset.max, 10) : null;
        const count = tier.querySelectorAll('.icon').length;
        // over-cap background/border
        if (cap && count > cap) tier.classList.add('overcap'); else tier.classList.remove('overcap');
        // live counters
        const key = tier.dataset.tier;
        if (hdr[key]) {
          hdr[key].textContent = String(count);
          if (cap && count > cap) hdr[key].classList.add('over'); else hdr[key].classList.remove('over');
        }
      });
    }

    function anyTierOverCap() {
      const tiers = document.querySelectorAll('.tier');
      for (const tier of tiers) {
        const cap = tier.dataset.max ? parseInt(tier.dataset.max, 10) : null;
        const count = tier.querySelectorAll('.icon').length;
        if (cap && count > cap) return true;
      }
      return false;
    }

    // ---------------------------
    // Persistence
    // ---------------------------
    const STORAGE_KEY = "stf-placements-v1";
    function savePlacements() {
      const { top3, high, mid, low, ni } = tierElements();
      const getNames = el => Array.from(el.querySelectorAll('.icon')).map(i => i.dataset.id);
      const data = {
        top3: getNames(top3),
        high: getNames(high),
        mid:  getNames(mid),
        low:  getNames(low),
        ni:   getNames(ni),
      };
      try { localStorage.setItem(STORAGE_KEY, JSON.stringify(data)); }
      catch(e){ console.warn("Failed to save placements:", e); }
    }
    function loadPlacements() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return null;
        return JSON.parse(raw);
      } catch(e) {
        console.warn("Failed to load placements:", e);
        return null;
      }
    }
    function clearPlacements() {
      try { localStorage.removeItem(STORAGE_KEY); } catch(e){}
    }

    // ---------------------------
    // Drag & Drop + Touch
    // ---------------------------
    const isCoarse = window.matchMedia && window.matchMedia("(pointer: coarse)").matches;

    let dragState = { draggingEl: null, originContainer: null, ghostEl: null };
    let mobileTargetTier = null;

    // Mobile tap-to-select controls (single instance injected under active tier)
    const mobileControls = document.createElement('div');
    mobileControls.className = 'mobile-controls hidden';
    const btnUp = document.createElement('button');   btnUp.textContent = 'Move Up';
    const btnDown = document.createElement('button'); btnDown.textContent = 'Move Down';
    mobileControls.append(btnUp, btnDown);

    let selectedIcon = null;
    function clearSelection() {
      if (selectedIcon) selectedIcon.classList.remove('selected');
      selectedIcon = null;
      mobileControls.classList.add('hidden');
      if (mobileControls.parentElement) mobileControls.parentElement.removeChild(mobileControls);
    }

    function moveSelected(dir) {
      if (!selectedIcon) return;
      const parent = selectedIcon.parentElement;
      const kids = Array.from(parent.querySelectorAll('.icon'));
      const idx = kids.indexOf(selectedIcon);
      if (idx === -1) return;
      const newIdx = idx + dir;
      if (newIdx < 0 || newIdx >= kids.length) return;
      if (dir < 0) parent.insertBefore(selectedIcon, kids[newIdx]);
      else parent.insertBefore(selectedIcon, kids[newIdx].nextSibling);
      updateTierHeadersAndCaps(); savePlacements();
    }
    btnUp.addEventListener('click', ()=> moveSelected(-1));
    btnDown.addEventListener('click',()=> moveSelected(1));

    function makeIconEl(item) {
      const el = document.createElement('div');
      el.className = 'icon'; el.draggable = true;
      el.dataset.id = item.name; el.dataset.entryId = item.entryId;
      el.setAttribute('aria-label', item.name);
      const img = document.createElement('img');
      img.alt = item.name; img.src = item.imgUrl;
      el.appendChild(img);

      // Desktop DnD
      el.addEventListener('dragstart', (e) => {
        if (isCoarse) { e.preventDefault(); return; } // disable native drag on mobile
        dragState.draggingEl = el;
        dragState.originContainer = el.parentElement;
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData('text/plain', el.dataset.id);
        requestAnimationFrame(()=>{ el.style.opacity = '0.5'; });
        clearSelection();
      });
      el.addEventListener('dragend', () => {
        if (isCoarse) return;
        el.style.opacity = '';
        dragState.draggingEl = null; dragState.originContainer = null;
        if (dragState.ghostEl) { dragState.ghostEl.remove(); dragState.ghostEl = null; }
        updateTierHeadersAndCaps(); savePlacements();
      });

      // Mobile: tap-to-select + tier-wide drag
      if (isCoarse) {
        let startX=0, startY=0, moved=false;

        el.addEventListener('touchstart', (e) => {
          const t = e.touches[0]; startX = t.clientX; startY = t.clientY; moved=false;
          dragState.draggingEl = el;
          dragState.originContainer = el.parentElement;
          el.style.opacity = '0.7';
        }, {passive:true});

        el.addEventListener('touchmove', (e) => {
          const t = e.touches[0];
          const dx = Math.abs(t.clientX - startX), dy = Math.abs(t.clientY - startY);
          if (dx + dy > 8) moved = true;

          // Tier-wide targeting: highlight entire tier, append on drop
          const target = document.elementFromPoint(t.clientX, t.clientY);
          const container = target ? target.closest('.tier, .palette') : null;
          if (!container) return;

          // update highlighting
          if (mobileTargetTier && mobileTargetTier !== container) {
            mobileTargetTier.classList.remove('targeting');
          }
          mobileTargetTier = container;
          mobileTargetTier.classList.add('targeting');
        }, {passive:false});

        el.addEventListener('touchend', (e) => {
          el.style.opacity = '';

          // If we barely moved, this is a tap: toggle selection
          if (!moved) {
            if (selectedIcon === el) { clearSelection(); return; }
            if (selectedIcon) selectedIcon.classList.remove('selected');
            selectedIcon = el;
            el.classList.add('selected');
            // inject controls right under this tier
            const tier = el.parentElement;
            tier.after(mobileControls);
            mobileControls.classList.remove('hidden');
            updateTierHeadersAndCaps(); savePlacements();
            return;
          }

          // Moved: drop into targeted tier, unless it's the same tier
          if (mobileTargetTier) {
            mobileTargetTier.classList.remove('targeting');
            if (mobileTargetTier !== dragState.originContainer) {
              mobileTargetTier.appendChild(el);
            }
          }
          mobileTargetTier = null;
          dragState.draggingEl = null;
          dragState.originContainer = null;

          clearSelection(); // dropping clears selection
          updateTierHeadersAndCaps(); savePlacements();
        });
      }

      return el;
    }

    function setupDragAndDrop() {
      if (isCoarse) {
        // Mobile: we do tier-wide highlighting/append in icon handlers; no container dnd needed.
        return;
      }
      // Desktop containers
      const droppables = document.querySelectorAll('.palette, .tier');
      droppables.forEach(container => {
        container.addEventListener('dragover', (e) => {
          e.preventDefault();
          const dragging = dragState.draggingEl; if (!dragging) return;
          if (!dragState.ghostEl) {
            dragState.ghostEl = document.createElement('div');
            dragState.ghostEl.className = 'ghost';
          }
          const before = findInsertionPoint(container, e.clientX);
          if (before) container.insertBefore(dragState.ghostEl, before);
          else container.appendChild(dragState.ghostEl);
        });
        container.addEventListener('drop', (e) => {
          e.preventDefault();
          const dragging = dragState.draggingEl; if (!dragging) return;
          const ghost = dragState.ghostEl;
          if (ghost && ghost.parentElement === container) {
            container.insertBefore(dragging, ghost);
            ghost.remove(); dragState.ghostEl = null;
          } else {
            container.appendChild(dragging);
          }
          updateTierHeadersAndCaps(); savePlacements();
        });
      });
    }

    // ---------------------------
    // Generation Logic (tier-direct, no concatenation)
    // ---------------------------
    function generatePrefill(parsed, iconData) {
      if (anyTierOverCap()) {
        alertSimple("One or more rows exceed their maximum. Please adjust before generating.");
        return;
      }
      const { top3: top3El, high: highEl, mid: midEl, low: lowEl } = tierElements();
      const getNames = el => Array.from(el.querySelectorAll('.icon')).map(i => i.dataset.id);

      const top3Names = getNames(top3El);
      const highNames = getNames(highEl);
      const midNames  = getNames(midEl);
      const lowNames  = getNames(lowEl);

      const nameToEntry = new Map(iconData.map(o => [o.name, o.entryId]));

      const params = new URLSearchParams();
      params.set('usp', 'pp_url');

      if (parsed.top1 && top3Names[0]) params.set(`entry.${parsed.top1}`, top3Names[0]);
      if (parsed.top2 && top3Names[1]) params.set(`entry.${parsed.top2}`, top3Names[1]);
      if (parsed.top3 && top3Names[2]) params.set(`entry.${parsed.top3}`, top3Names[2]);

      for (const n of highNames) { const id = nameToEntry.get(n); if (id) params.append(`entry.${id}`, "high (5max)"); }
      for (const n of midNames)  { const id = nameToEntry.get(n); if (id) params.append(`entry.${id}`, "medium (10max)"); }
      for (const n of lowNames)  { const id = nameToEntry.get(n); if (id) params.append(`entry.${id}`, "low (15max)"); }

      const base = parsed.url;
      if (!base) { alertWithContact("Missing form base `url` in data."); return; }
      const theLink = `${base}?${params.toString()}`;
      console.log("Prefill URL:", theLink);
      window.open(theLink, "_blank");
    }

    // ---------------------------
    // Reset
    // ---------------------------
    function resetAllToPalette() {
      const ok = confirm("Reset all placements and move all items back to the palette?");
      if (!ok) return;
      const { palette, top3, high, mid, low, ni } = tierElements();
      const allPlaced = [top3, high, mid, low, ni].flatMap(el => Array.from(el.querySelectorAll('.icon')));
      allPlaced.forEach(icon => palette.appendChild(icon));
      clearSelection();
      clearPlacements();
      updateTierHeadersAndCaps();
    }

    // ---------------------------
    // Boot
    // ---------------------------
    (function init() {
      try {
        const dataParam = getParam('data');
        if (!dataParam) { alertWithContact("No data parameter found."); return; }

        function proceedWhenLZReady() {
          if (!window.LZString) { setTimeout(proceedWhenLZReady, 20); return; }
          try {
            const json = LZString.decompressFromEncodedURIComponent(dataParam);
            if (!json) throw new Error("Decompression produced empty result");
            const parsed = JSON.parse(json);

            const icons = convertToIconData(parsed);
            const { palette, top3, high, mid, low, ni } = tierElements();

            // Render all icons to palette
            const byName = new Map();
            icons.forEach(item => {
              const el = makeIconEl(item);
              palette.appendChild(el);
              byName.set(item.name, el);
            });

            // Restore placements
            const saved = loadPlacements();
            if (saved) {
              const apply = (arr, container) => (arr || []).forEach(name => {
                const el = byName.get(name); if (el) container.appendChild(el);
              });
              apply(saved.top3, top3);
              apply(saved.high, high);
              apply(saved.mid,  mid);
              apply(saved.low,  low);
              apply(saved.ni,   ni);
            }

            updateTierHeadersAndCaps();
            setupDragAndDrop();

            document.getElementById('fillBtn').addEventListener('click', () => {
              try { generatePrefill(parsed, icons); }
              catch(e){ console.error(e); alertWithContact("Failed to generate prefill URL: " + e.message); }
            });
            document.getElementById('resetBtn').addEventListener('click', resetAllToPalette);

            // Tapping outside selection clears mobile selection
            document.addEventListener('click', (e)=>{
              if (isCoarse && selectedIcon && !e.target.closest('.icon') && !e.target.closest('.mobile-controls')) {
                clearSelection();
              }
            });

          } catch (e) {
            console.error(e);
            alertWithContact("Failed to decode data: " + e.message);
          }
        }
        proceedWhenLZReady();

      } catch (e) {
        console.error(e);
        alertWithContact("Unexpected error: " + e.message);
      }
    })();
  </script>
</body>
</html>
