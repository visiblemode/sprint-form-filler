<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mathcord Sprint Tier Maker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: white;
            overflow-x: hidden;
            padding-bottom: 140px; /* Space for fixed carousel */
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .tier-list {
            margin-bottom: 20px;
        }

        .tier {
            display: flex;
            min-height: 100px;
            margin-bottom: 2px;
            border: 2px solid #333;
        }

        .tier-label {
            width: 140px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
            color: black;
            flex-shrink: 0;
        }

        .tier-content {
            flex: 1;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            padding: 10px;
            background: #2a2a2a;
            min-height: 100px;
            align-items: flex-start;
            align-content: flex-start;
            position: relative;
        }

        .tier-content.drag-over {
            background: #3a3a3a;
            border: 2px dashed #666;
        }

        .insertion-indicator {
            width: 3px;
            height: 60px;
            background: #4CAF50;
            border-radius: 2px;
            position: absolute;
            z-index: 50;
            pointer-events: none;
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.6);
        }

        .top3 { background: #ff6b6b; }
        .high { background: #ffd93d; }
        .mid { background: #6bcf7f; }
        .low { background: #4ecdc4; }
        .not-interested { background: #95a5a6; }

        .icon-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #333;
            padding: 15px 20px 20px 20px;
            border-top: 3px solid #555;
            z-index: 100;
            box-shadow: 0 -5px 15px rgba(0,0,0,0.3);
        }

        .icon-container h3 {
            margin-bottom: 15px;
            text-align: center;
        }

        .icons-grid {
            display: flex;
            overflow-x: auto;
            flex-wrap: nowrap;
            gap: 10px;
            justify-content: flex-start;
            padding: 5px 10px;
        }

        .icon {
            width: 80px;
            height: 80px;
            background-size: cover;
            background-position: center;
            border-radius: 10px;
            cursor: grab;
            transition: transform 0.2s, box-shadow 0.2s;
            flex-shrink: 0;
        }

        .icon:hover {
            transform: scale(1.05);
            box-shadow: inset 0 0 0 2px #fff;
        }

        .icon.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
        }

        .icon.in-tier {
            width: 60px;
            height: 60px;
        }

        .generate-btn {
            display: block;
            margin: 30px auto 20px auto;
            padding: 15px 30px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 18px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .generate-btn:hover {
            background: #45a049;
        }

        /* Mobile styles */
        @media (max-width: 768px) {
            body {
                padding-bottom: 120px; /* Smaller space for mobile */
            }
            
            .tier-label {
                width: 100px;
                font-size: 12px;
                text-align: center;
            }
            
            .tier-content {
                min-height: 80px;
            }
            
            .icon-container {
                padding: 10px 15px;
            }
            
            .icon-container h3 {
                font-size: 14px;
                margin-bottom: 10px;
            }
            
            .icons-grid {
                padding-bottom: 5px;
            }
            
            .icon {
                flex-shrink: 0;
                width: 60px;
                height: 60px;
            }
            
            .icon.in-tier {
                width: 45px;
                height: 45px;
            }
        }

        /* Scrollbar styling for carousel */
        .icons-grid::-webkit-scrollbar {
            height: 6px;
        }

        .icons-grid::-webkit-scrollbar-track {
            background: #444;
            border-radius: 3px;
        }

        .icons-grid::-webkit-scrollbar-thumb {
            background: #666;
            border-radius: 3px;
        }

        .icons-grid::-webkit-scrollbar-thumb:hover {
            background: #777;
        }
    </style>
</head>
<body>
    <div class="container">        
        <div class="tier-list">
            <div class="tier">
                <div class="tier-label top3">Top 3</div>
                <div class="tier-content" data-tier="top3"></div>
            </div>
            
            <div class="tier">
                <div class="tier-label high">High</div>
                <div class="tier-content" data-tier="high"></div>
            </div>
            
            <div class="tier">
                <div class="tier-label mid">Mid</div>
                <div class="tier-content" data-tier="mid"></div>
            </div>
            
            <div class="tier">
                <div class="tier-label low">Low</div>
                <div class="tier-content" data-tier="low"></div>
            </div>
            
            <div class="tier">
                <div class="tier-label not-interested">Not Interested</div>
                <div class="tier-content" data-tier="not-interested"></div>
            </div>
        </div>

        <div class="icon-container">
            <h3>Drag items up into tiers â†‘</h3>
            <div class="icons-grid" id="iconsGrid"></div>
        </div>

        <button class="generate-btn" onclick="generateTierList()">Fill Google Form</button>
    </div>

    <script language="javascript" src="lz-string.min.js"></script>
    <script>

        function getParam(name) {
            // Prefer hash for privacy: #data=...
            const hash = new URLSearchParams(location.hash.slice(1));

            console.log(hash)
            if (hash.has(name)) return hash.get(name);
            // Fallback to query: ?data=...
            const qs = new URLSearchParams(location.search);

            console.log('qs', qs)
            return qs.get(name);
        }

        const enc = getParam('data');
        let iconData = {};
        let dataObject = {};
        if (!enc) {
            alert('No data parameter found.');
        } else {
            try {
                const json = LZString.decompressFromEncodedURIComponent(enc);
                const jsonObject = JSON.parse(json);
                console.log("?", json)
                dataObject = jsonObject;
                iconData = convertToIconData(jsonObject);
            } catch (e) {
                alert('Failed to decode data: ' + e.message);
            }
        }

        function convertToIconData(data) {
            console.log("her;", data.pokemon)
            if (!data || !Array.isArray(data.pokemon)) {
                throw new Error("Invalid data format: expected an object with a 'pokemon' array");
            }

            return data.pokemon.map(([name, _num, imageUrl]) => {
                return {
                    id: name,
                    // id: name.replace(/[^a-z0-9]+/g, ""), // lowercase, strip spaces/punct
                    url: `https://www.serebii.net/pokemonsleep/pokemon/icon/${imageUrl}`
                };
            });
        }

        let draggedElement = null;
        let touchOffset = { x: 0, y: 0 };

        // Initialize the app
        function init() {
            loadIcons();
            setupDragAndDrop();
        }

        // Load icons from "external" JSON
        function loadIcons() {
            const iconsGrid = document.getElementById('iconsGrid');
            
            iconData.forEach(item => {
                const iconElement = document.createElement('div');
                iconElement.className = 'icon';
                iconElement.draggable = true;
                iconElement.dataset.id = item.id;
                iconElement.style.backgroundImage = `url(${item.url})`;
                
                iconsGrid.appendChild(iconElement);
            });
        }

        // Setup drag and drop for both desktop and mobile
        function setupDragAndDrop() {
            const icons = document.querySelectorAll('.icon');
            const tierContents = document.querySelectorAll('.tier-content');

            // Desktop drag and drop
            icons.forEach(icon => {
                icon.addEventListener('dragstart', handleDragStart);
                icon.addEventListener('dragend', handleDragEnd);
                
                // Mobile touch events
                icon.addEventListener('touchstart', handleTouchStart, { passive: false });
                icon.addEventListener('touchmove', handleTouchMove, { passive: false });
                icon.addEventListener('touchend', handleTouchEnd, { passive: false });
            });

            tierContents.forEach(tier => {
                tier.addEventListener('dragover', handleDragOver);
                tier.addEventListener('drop', handleDrop);
                tier.addEventListener('dragenter', handleDragEnter);
                tier.addEventListener('dragleave', handleDragLeave);
            });
        }

        // Desktop drag handlers
        function handleDragStart(e) {
            draggedElement = e.target;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            draggedElement = null;
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            const tierContent = e.target.closest('.tier-content');
            if (tierContent) {
                showInsertionIndicator(tierContent, e.clientX);
            }
        }

        function handleDragEnter(e) {
            e.preventDefault();
            const tierContent = e.target.closest('.tier-content');
            if (tierContent) {
                tierContent.classList.add('drag-over');
            }
        }

        function handleDragLeave(e) {
            const tierContent = e.target.closest('.tier-content');
            if (tierContent && !tierContent.contains(e.relatedTarget)) {
                tierContent.classList.remove('drag-over');
                hideInsertionIndicator();
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            const tierContent = e.target.closest('.tier-content');
            if (tierContent) {
                tierContent.classList.remove('drag-over');
            }
            hideInsertionIndicator();
            
            if (draggedElement && tierContent) {
                const insertionPoint = findInsertionPoint(tierContent, e.clientX);
                moveIconToTier(draggedElement, tierContent, insertionPoint);
            }
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            hideInsertionIndicator();
            draggedElement = null;
        }

        // Visual insertion indicator functions
        function showInsertionIndicator(tierContent, clientX) {
            hideInsertionIndicator(); // Remove any existing indicator
            
            const insertionPoint = findInsertionPoint(tierContent, clientX);
            const indicator = document.createElement('div');
            indicator.className = 'insertion-indicator';
            indicator.id = 'insertion-indicator';
            
            if (insertionPoint) {
                const rect = insertionPoint.getBoundingClientRect();
                const tierRect = tierContent.getBoundingClientRect();
                indicator.style.left = (rect.left - tierRect.left - 2) + 'px';
                indicator.style.top = '20px';
            } else {
                // Insert at the end
                const icons = tierContent.querySelectorAll('.icon');
                if (icons.length > 0) {
                    const lastIcon = icons[icons.length - 1];
                    const rect = lastIcon.getBoundingClientRect();
                    const tierRect = tierContent.getBoundingClientRect();
                    indicator.style.left = (rect.right - tierRect.left + 3) + 'px';
                    indicator.style.top = '20px';
                } else {
                    indicator.style.left = '10px';
                    indicator.style.top = '20px';
                }
            }
            
            tierContent.style.position = 'relative';
            tierContent.appendChild(indicator);
        }

        function hideInsertionIndicator() {
            const indicator = document.getElementById('insertion-indicator');
            if (indicator) {
                indicator.remove();
            }
        }

        // Mobile touch handlers
        function handleTouchStart(e) {
            e.preventDefault();
            draggedElement = e.target;
            e.target.classList.add('dragging');
            
            const touch = e.touches[0];
            const rect = e.target.getBoundingClientRect();
            touchOffset.x = touch.clientX - rect.left;
            touchOffset.y = touch.clientY - rect.top;
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            if (!draggedElement) return;

            const touch = e.changedTouches[0];
            const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
            const tierContent = elementBelow ? elementBelow.closest('.tier-content') : null;

            // Reset styles
            draggedElement.style.position = '';
            draggedElement.style.zIndex = '';
            draggedElement.style.left = '';
            draggedElement.style.top = '';
            draggedElement.style.pointerEvents = '';
            draggedElement.classList.remove('dragging');
            hideInsertionIndicator();

            if (tierContent) {
                const insertionPoint = findInsertionPoint(tierContent, touch.clientX);
                moveIconToTier(draggedElement, tierContent, insertionPoint);
            }

            draggedElement = null;
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (!draggedElement) return;

            const touch = e.touches[0];
            draggedElement.style.position = 'fixed';
            draggedElement.style.zIndex = '1000';
            draggedElement.style.left = (touch.clientX - touchOffset.x) + 'px';
            draggedElement.style.top = (touch.clientY - touchOffset.y) + 'px';
            draggedElement.style.pointerEvents = 'none';

            // Show insertion indicator for mobile too
            const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
            const tierContent = elementBelow ? elementBelow.closest('.tier-content') : null;
            if (tierContent) {
                showInsertionIndicator(tierContent, touch.clientX);
            } else {
                hideInsertionIndicator();
            }
        }

        // Move icon to tier with proper positioning
        function moveIconToTier(icon, tierContent, insertPosition = null) {
            icon.classList.add('in-tier');
            
            if (insertPosition) {
                // Insert before the specified position
                tierContent.insertBefore(icon, insertPosition);
            } else {
                // Just append to the end
                tierContent.appendChild(icon);
            }
            // Re-setup event listeners for the moved icon
            icon.removeEventListener('dragstart', handleDragStart);
            icon.removeEventListener('dragend', handleDragEnd);
            icon.removeEventListener('touchstart', handleTouchStart);
            icon.removeEventListener('touchmove', handleTouchMove);
            icon.removeEventListener('touchend', handleTouchEnd);
            
            icon.addEventListener('dragstart', handleDragStart);
            icon.addEventListener('dragend', handleDragEnd);
            icon.addEventListener('touchstart', handleTouchStart, { passive: false });
            icon.addEventListener('touchmove', handleTouchMove, { passive: false });
            icon.addEventListener('touchend', handleTouchEnd, { passive: false });
        }

        // Find the best insertion point in a tier
        function findInsertionPoint(tierContent, clientX) {
            const icons = Array.from(tierContent.querySelectorAll('.icon'));
            
            if (icons.length === 0) {
                return null; // Empty tier, just append
            }

            for (let i = 0; i < icons.length; i++) {
                const rect = icons[i].getBoundingClientRect();
                const iconCenterX = rect.left + rect.width / 2;
                
                if (clientX < iconCenterX) {
                    return icons[i]; // Insert before this icon
                }
            }
            
            return null; // Insert at the end
        }

        // Generate tier list and print to console
        function generateTierList() {
            const tierList = {
                'top3': [],
                'high': [],
                'mid': [],
                'low': [],
                'not-interested': []
            };

            // Get items in each tier
            document.querySelectorAll('.tier-content').forEach(tierContent => {
                const tierName = tierContent.dataset.tier;
                const icons = tierContent.querySelectorAll('.icon');
                
                icons.forEach(icon => {
                    tierList[tierName].push(icon.dataset.id);
                });
            });

            // Add items still in the icons grid to "not-interested"
            const iconsGrid = document.getElementById('iconsGrid');
            const remainingIcons = iconsGrid.querySelectorAll('.icon');
            remainingIcons.forEach(icon => {
                tierList['not-interested'].push(icon.dataset.id);
            });

            // Gather all Pokemon in the specified order with limits
            const allPokemon = [
                ...tierList['top3'],
                ...tierList['high'],
                ...tierList['mid'],
                ...tierList['low']
            ];

            const tierData = {
                'top3': allPokemon.slice(0, 3),
                'high': allPokemon.slice(3, 8),
                'mid': allPokemon.slice(8, 18),
                'low': allPokemon.slice(18, 33),
            }

            // Get the base URL from iconData
            const baseUrl = dataObject.url;
            
            // Get top 3 entry IDs
            const top1Id = dataObject.top1;
            const top2Id = dataObject.top2;
            const top3Id = dataObject.top3;
            
            // Create a lookup map for pokemon name -> entry ID
            const pokemonToEntryId = {};
            dataObject.pokemon.forEach(([name, entryId, imageFile]) => {
                pokemonToEntryId[name] = entryId;
            });
            
            // Build URL parameters
            const params = new URLSearchParams();
            params.append('usp', 'pp_url');
            
            // Handle top 3 (fill specific entry fields)
            const top3List = tierData.top3 || [];
            if (top3List[0]) params.append(`entry.${top1Id}`, top3List[0]);
            if (top3List[1]) params.append(`entry.${top2Id}`, top3List[1]);
            if (top3List[2]) params.append(`entry.${top3Id}`, top3List[2]);
            
            // Handle other tiers - map tier names to their labels
            const tierLabels = {
                'high': 'high (5max)',
                'mid': 'medium (10max)', 
                'low': 'low (15max)'
            };
            
            // Process each tier
            Object.keys(tierLabels).forEach(tierName => {
                const pokemonList = tierData[tierName] || [];
                const tierLabel = tierLabels[tierName];
                
                pokemonList.forEach(pokemonName => {
                    const entryId = pokemonToEntryId[pokemonName];
                    if (entryId) {
                        params.append(`entry.${entryId}`, tierLabel);
                    }
                });
            });
            
            const theLink = `${baseUrl}?${params.toString()}`
            window.open(theLink, "_blank");
            console.log('Shareable Link:', theLink);
        }

        // Initialize the app when page loads
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>


