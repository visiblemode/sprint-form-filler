<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Sprint Tier Filler</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Dependency per spec -->
  <script src="lz-string.min.js"></script>
  <!-- Optional fallback if local file missing -->
  <script>
    (function ensureLZ(){
      if (!window.LZString) {
        var s = document.createElement('script');
        s.src = "https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js";
        document.head.appendChild(s);
      }
    })();
  </script>
  <style>
    :root{
      /* Pastels on dark */
      --pastel-red:    rgba(255, 107, 129, 0.28);
      --pastel-yellow: rgba(255, 221,  87, 0.28);
      --pastel-green:  rgba( 46, 204, 113, 0.28);
      --pastel-teal:   rgba( 26, 188, 156, 0.28);
      --pastel-grey:   rgba(200, 200, 200, 0.28);
      /* Overcap */
      --overcap-fill:  rgba(220,  53,  69, 0.35);
      --overcap-border:#dc3545;
      --text: #eaeaea;
      --muted:#bdbdbd;
      --line:#666;
    }

    /* Global dark + no text drag / selection */
    html, body { height: 100%; }
    body {
      font-family: system-ui, sans-serif; margin: 12px;
      background:#000; color: var(--text);
      -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
      user-select: none;
      -webkit-user-select: none;
    }
    * { -webkit-tap-highlight-color: transparent; }
    img { -webkit-user-drag: none; user-drag: none; }

    h2 { margin: 12px 0 6px; font-size: 1rem; color:#fff; }
    .app { display: grid; gap: 16px; }

    .tip { color: var(--muted); font-size: 0.95rem; }

    .row { display: grid; gap: 8px; }
    .row-head { display:flex; align-items:baseline; gap:10px; flex-wrap:wrap; }
    .row-head .live { font-weight:600; }
    .row-head .count { font-variant-numeric: tabular-nums; }
    .row-head .count.over { color: var(--overcap-border); } /* just the X */

    .palette, .tier {
      border: 1px dashed var(--line); /* 1px as requested */
      padding: 8px;
      min-height: 64px;
      display: flex;
      flex-wrap: wrap;
      align-items: flex-start;
      gap: 6px;
      position: relative;
      border-radius: 10px; /* soft corners */
      overflow: hidden;    /* keep contents within rounded corners */
      background: rgba(255,255,255,0.03); /* subtle for palette */
      touch-action: none; /* help prevent scroll during drag */
    }

    /* Per-tier pastel fills (on dark) */
    #tier-top3 { background: var(--pastel-red); }
    #tier-high { background: var(--pastel-yellow); }
    #tier-mid  { background: var(--pastel-green); }
    #tier-low  { background: var(--pastel-teal); }
    #tier-ni   { background: var(--pastel-grey); }

    /* Overcap: stronger red and thicker dashed border */
    .tier.overcap {
      background: var(--overcap-fill) !important;
      border: 2px dashed var(--overcap-border);
    }

    .icon {
      width: 56px; height: 56px;
      border: 1px solid var(--line);  /* 1px border */
      border-radius: 10px;            /* rounded corners */
      background: #111 center/contain no-repeat;
      display: inline-flex; align-items: center; justify-content: center;
      cursor: grab; touch-action: none; position: relative;
      overflow: hidden;               /* ensure image stays within rounded corners */
    }
    .icon:active { cursor: grabbing; }
    .icon img {
      width: 100%; height: 100%; object-fit: contain; pointer-events: none;
      display:block; border-radius: inherit;
      background: transparent;
      draggable: false;
    }

    .ghost {
      width: 56px; height: 56px;
      outline: 2px solid #888; outline-offset: -2px; border-radius: 10px;
      background: repeating-linear-gradient(45deg,#1b1b1b,#1b1b1b 6px,#131313 6px,#131313 12px);
    }

    /* mirror that follows the finger on touch/coarse pointers */
    .drag-mirror {
      position: fixed; pointer-events: none; z-index: 9999;
      width: 56px; height: 56px; border-radius: 10px;
      border: 1px solid var(--line); background:#111;
      opacity: 0.85; transform: translate(-50%, -50%);
      display:flex; align-items:center; justify-content:center;
    }
    .drag-mirror img { width:100%; height:100%; object-fit:contain; border-radius:inherit; }

    .controls { display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
    button {
      padding: 8px 12px; border:1px solid var(--line); background:#121212; color: var(--text);
      border-radius: 8px; cursor: pointer;
    }
    button:active { transform: translateY(1px); }

    .small { font-size: 0.9rem; color: var(--muted); }
  </style>
</head>
<body>
  <div class="app">
    <!-- Tip stays at top -->
    <div class="tip">
      Drag items into tiers. Over-cap rows turn light red. Palette items are treated as Not Interested (not submitted).
    </div>

    <!-- Tiers -->
    <section class="row">
      <div class="row-head">
        <h2>Top 3 (<span class="live">Current: <span id="cnt-top3" class="count">0</span>/3</span>)</h2>
      </div>
      <div id="tier-top3" class="tier" data-tier="top3" data-max="3" aria-label="Top 3"></div>
    </section>

    <section class="row">
      <div class="row-head">
        <h2>High (<span class="live">Current: <span id="cnt-high" class="count">0</span>/5</span>)</h2>
      </div>
      <div id="tier-high" class="tier" data-tier="high" data-max="5" aria-label="High"></div>
    </section>

    <section class="row">
      <div class="row-head">
        <h2>Mid (<span class="live">Current: <span id="cnt-mid" class="count">0</span>/10</span>)</h2>
      </div>
      <div id="tier-mid" class="tier" data-tier="mid" data-max="10" aria-label="Mid"></div>
    </section>

    <section class="row">
      <div class="row-head">
        <h2>Low (<span class="live">Current: <span id="cnt-low" class="count">0</span>/15</span>)</h2>
      </div>
      <div id="tier-low" class="tier" data-tier="low" data-max="15" aria-label="Low"></div>
    </section>

    <section class="row">
      <div class="row-head">
        <h2>Not Interested</h2>
      </div>
      <div id="tier-ni" class="tier" data-tier="ni" aria-label="Not Interested"></div>
    </section>

    <!-- Controls + Palette below tiers -->
    <section class="row">
      <div class="controls">
        <button id="fillBtn">Fill Google Form</button>
        <button id="resetBtn" title="Move all items back to the palette">Reset</button>
        <span class="small">Palette is below â€” items left here are not submitted.</span>
      </div>
      <div class="row-head">
        <h2>Palette</h2>
      </div>
      <div id="palette" class="palette" data-tier="palette" aria-label="Palette"></div>
    </section>
  </div>

  <script>
    // ---------------------------
    // Helpers
    // ---------------------------
    function alertWithContact(msg) {
      alert(msg + "\n\nPlease notify @dovemail on Discord about this error");
    }
    function alertSimple(msg) { alert(msg); }

    function getParam(name) {
      const fromHash = new URLSearchParams((location.hash || "").replace(/^#/, ""));
      if (fromHash.has(name)) return fromHash.get(name);
      const fromQuery = new URLSearchParams(location.search);
      if (fromQuery.has(name)) return fromQuery.get(name);
      return null;
    }

    function convertToIconData(parsed) {
      if (!Array.isArray(parsed.pokemon)) throw new Error("`pokemon` must be an array");
      return parsed.pokemon.map(item => {
        if (!Array.isArray(item) || item.length < 3) {
          throw new Error("Each pokemon item must be [displayName, entryId, imageFile]");
        }
        const [displayName, entryId, imageFile] = item;
        const imgUrl = `https://www.serebii.net/pokemonsleep/pokemon/icon/${imageFile}`;
        return { name: displayName, entryId, imgUrl };
      });
    }

    // 2-D insertion heuristic for multi-row tiers
    function findInsertionPoint2D(container, x, y) {
      const children = Array.from(container.querySelectorAll('.icon'));
      for (const child of children) {
        const r = child.getBoundingClientRect();
        const centerX = r.left + r.width / 2;
        const centerY = r.top  + r.height / 2;

        // If the pointer is above the center of this child, insert before it.
        if (y < centerY - 2) return child;

        // If we're on the same row band, use X to decide before/after within the row.
        if (y >= r.top && y <= r.bottom && x < centerX) return child;
      }
      return null; // append
    }

    function tierElements() {
      return {
        palette: document.getElementById('palette'),
        top3: document.getElementById('tier-top3'),
        high: document.getElementById('tier-high'),
        mid: document.getElementById('tier-mid'),
        low: document.getElementById('tier-low'),
        ni: document.getElementById('tier-ni'),
      };
    }

    function headerSpans() {
      return {
        top3: document.getElementById('cnt-top3'),
        high: document.getElementById('cnt-high'),
        mid:  document.getElementById('cnt-mid'),
        low:  document.getElementById('cnt-low'),
      };
    }

    function updateTierHeadersAndCaps() {
      const tiers = document.querySelectorAll('.tier');
      const hdr = headerSpans();
      tiers.forEach(tier => {
        const cap = tier.dataset.max ? parseInt(tier.dataset.max, 10) : null;
        const count = tier.querySelectorAll('.icon').length;
        if (cap && count > cap) tier.classList.add('overcap'); else tier.classList.remove('overcap');
        const key = tier.dataset.tier;
        if (hdr[key]) {
          hdr[key].textContent = String(count);
          if (cap && count > cap) hdr[key].classList.add('over'); else hdr[key].classList.remove('over');
        }
      });
    }

    function anyTierOverCap() {
      const tiers = document.querySelectorAll('.tier');
      for (const tier of tiers) {
        const cap = tier.dataset.max ? parseInt(tier.dataset.max, 10) : null;
        const count = tier.querySelectorAll('.icon').length;
        if (cap && count > cap) return true;
      }
      return false;
    }

    // ---------------------------
    // Persistence
    // ---------------------------
    const STORAGE_KEY = "stf-placements-v1";
    function savePlacements() {
      const { top3, high, mid, low, ni } = tierElements();
      const getNames = el => Array.from(el.querySelectorAll('.icon')).map(i => i.dataset.id);
      const data = {
        top3: getNames(top3),
        high: getNames(high),
        mid:  getNames(mid),
        low:  getNames(low),
        ni:   getNames(ni),
      };
      try { localStorage.setItem(STORAGE_KEY, JSON.stringify(data)); }
      catch(e){ console.warn("Failed to save placements:", e); }
    }
    function loadPlacements() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return null;
        return JSON.parse(raw);
      } catch(e) {
        console.warn("Failed to load placements:", e);
        return null;
      }
    }
    function clearPlacements() { try { localStorage.removeItem(STORAGE_KEY); } catch(e){} }

    // ---------------------------
    // Drag & Drop
    // Desktop (mouse): keep HTML5 DnD.
    // Touch/Coarse pointers: custom Pointer Events drag with mirror + 2D insertion.
    // ---------------------------
    const IS_COARSE = window.matchMedia && window.matchMedia('(pointer: coarse)').matches || navigator.maxTouchPoints > 0;

    let dragState = { draggingEl: null, originContainer: null, ghostEl: null, mirrorEl: null, pointerId: null };

    function makeIconEl(item) {
      const el = document.createElement('div');
      el.className = 'icon';
      el.dataset.id = item.name; el.dataset.entryId = item.entryId;
      el.setAttribute('aria-label', item.name);

      const img = document.createElement('img');
      img.alt = item.name; img.src = item.imgUrl; img.draggable = false;
      el.appendChild(img);

      if (!IS_COARSE) {
        // Desktop HTML5 DnD
        el.draggable = true;
        el.addEventListener('dragstart', (e) => {
          dragState.draggingEl = el;
          dragState.originContainer = el.parentElement;
          e.dataTransfer.effectAllowed = "move";
          e.dataTransfer.setData('text/plain', el.dataset.id);
          requestAnimationFrame(()=>{ el.style.opacity = '0.5'; });
        });
        el.addEventListener('dragend', () => {
          el.style.opacity = '';
          dragState.draggingEl = null; dragState.originContainer = null;
          if (dragState.ghostEl) { dragState.ghostEl.remove(); dragState.ghostEl = null; }
          updateTierHeadersAndCaps(); savePlacements();
        });
      } else {
        // Pointer Events drag (mobile/tablet)
        el.draggable = false;
        el.addEventListener('pointerdown', (e) => {
          if (e.button !== 0) return;
          dragState.pointerId = e.pointerId;
          dragState.draggingEl = el;
          dragState.originContainer = el.parentElement;

          // create mirror
          dragState.mirrorEl = document.createElement('div');
          dragState.mirrorEl.className = 'drag-mirror';
          const mImg = document.createElement('img');
          mImg.src = img.src; mImg.alt = img.alt;
          dragState.mirrorEl.appendChild(mImg);
          document.body.appendChild(dragState.mirrorEl);
          positionMirror(e.clientX, e.clientY);

          // create ghost to mark insertion spot
          if (!dragState.ghostEl) {
            dragState.ghostEl = document.createElement('div');
            dragState.ghostEl.className = 'ghost';
          }

          el.setPointerCapture(e.pointerId);
        });

        el.addEventListener('pointermove', (e) => {
          if (dragState.pointerId !== e.pointerId || !dragState.mirrorEl) return;
          e.preventDefault(); // stop page scroll
          positionMirror(e.clientX, e.clientY);

          const target = document.elementFromPoint(e.clientX, e.clientY);
          const container = target ? target.closest('.tier, .palette') : null;
          if (!container) return;

          const before = findInsertionPoint2D(container, e.clientX, e.clientY);
          if (before) container.insertBefore(dragState.ghostEl, before);
          else container.appendChild(dragState.ghostEl);
        }, {passive:false});

        el.addEventListener('pointerup', (e) => finishPointerDrag(e));
        el.addEventListener('pointercancel', (e) => finishPointerDrag(e));
      }

      return el;
    }

    function positionMirror(x, y) {
      if (!dragState.mirrorEl) return;
      dragState.mirrorEl.style.left = x + 'px';
      dragState.mirrorEl.style.top  = y + 'px';
    }

    function finishPointerDrag(e) {
      if (dragState.pointerId !== e.pointerId) return;

      // drop into ghost location if present
      if (dragState.ghostEl && dragState.ghostEl.parentElement && dragState.draggingEl) {
        dragState.ghostEl.parentElement.insertBefore(dragState.draggingEl, dragState.ghostEl);
      }
      // cleanup
      if (dragState.ghostEl) { dragState.ghostEl.remove(); dragState.ghostEl = null; }
      if (dragState.mirrorEl) { dragState.mirrorEl.remove(); dragState.mirrorEl = null; }
      dragState.draggingEl = null;
      dragState.originContainer = null;
      dragState.pointerId = null;

      updateTierHeadersAndCaps(); savePlacements();
    }

    function setupDragAndDrop() {
      // Desktop droppables (HTML5 DnD)
      if (!IS_COARSE) {
        const droppables = document.querySelectorAll('.palette, .tier');
        droppables.forEach(container => {
          container.addEventListener('dragover', (e) => {
            e.preventDefault();
            const dragging = dragState.draggingEl; if (!dragging) return;

            if (!dragState.ghostEl) {
              dragState.ghostEl = document.createElement('div');
              dragState.ghostEl.className = 'ghost';
            }
            const before = findInsertionPoint2D(container, e.clientX, e.clientY);
            if (before) container.insertBefore(dragState.ghostEl, before);
            else container.appendChild(dragState.ghostEl);
          });

          container.addEventListener('drop', (e) => {
            e.preventDefault();
            const dragging = dragState.draggingEl; if (!dragging) return;
            const ghost = dragState.ghostEl;
            if (ghost && ghost.parentElement === container) {
              container.insertBefore(dragging, ghost);
              ghost.remove(); dragState.ghostEl = null;
            } else {
              container.appendChild(dragging);
            }
            updateTierHeadersAndCaps(); savePlacements();
          });
        });

        // Prevent accidental dragging of text/images outside icons
        document.addEventListener('dragstart', (e) => {
          if (!(e.target && e.target.classList && e.target.classList.contains('icon'))) {
            e.preventDefault();
          }
        });
      }
    }

    // ---------------------------
    // Generation Logic (per your revised rules)
    // ---------------------------
    function generatePrefill(parsed, iconData) {
      if (anyTierOverCap()) {
        alertSimple("One or more rows exceed their maximum. Please adjust before generating.");
        return;
      }

      const { top3: top3El, high: highEl, mid: midEl, low: lowEl } = tierElements();
      const getNames = el => Array.from(el.querySelectorAll('.icon')).map(i => i.dataset.id);

      const top3Names = getNames(top3El);
      const highNames = getNames(highEl);
      const midNames  = getNames(midEl);
      const lowNames  = getNames(lowEl);

      const nameToEntry = new Map(iconData.map(o => [o.name, o.entryId]));

      const params = new URLSearchParams();
      params.set('usp', 'pp_url');

      if (parsed.top1 && top3Names[0]) params.set(`entry.${parsed.top1}`, top3Names[0]);
      if (parsed.top2 && top3Names[1]) params.set(`entry.${parsed.top2}`, top3Names[1]);
      if (parsed.top3 && top3Names[2]) params.set(`entry.${parsed.top3}`, top3Names[2]);

      for (const n of highNames) { const id = nameToEntry.get(n); if (id) params.append(`entry.${id}`, "high (5max)"); }
      for (const n of midNames)  { const id = nameToEntry.get(n); if (id) params.append(`entry.${id}`, "medium (10max)"); }
      for (const n of lowNames)  { const id = nameToEntry.get(n); if (id) params.append(`entry.${id}`, "low (15max)"); }

      const base = parsed.url;
      if (!base) { alertWithContact("Missing form base `url` in data."); return; }
      const theLink = `${base}?${params.toString()}`;
      console.log("Prefill URL:", theLink);
      window.open(theLink, "_blank");
    }

    // ---------------------------
    // Reset
    // ---------------------------
    function resetAllToPalette() {
      const ok = confirm("Reset all placements and move all items back to the palette?");
      if (!ok) return;
      const { palette, top3, high, mid, low, ni } = tierElements();
      const allPlaced = [top3, high, mid, low, ni]
        .flatMap(el => Array.from(el.querySelectorAll('.icon')));
      allPlaced.forEach(icon => palette.appendChild(icon));
      clearPlacements();
      updateTierHeadersAndCaps();
    }

    // ---------------------------
    // Boot
    // ---------------------------
    (function init() {
      try {
        const dataParam = getParam('data');
        if (!dataParam) { alertWithContact("No data parameter found."); return; }

        function proceedWhenLZReady() {
          if (!window.LZString) { setTimeout(proceedWhenLZReady, 20); return; }
          try {
            const json = LZString.decompressFromEncodedURIComponent(dataParam);
            if (!json) throw new Error("Decompression produced empty result");
            const parsed = JSON.parse(json);

            const icons = convertToIconData(parsed);
            const { palette, top3, high, mid, low, ni } = tierElements();

            // Render icons into palette
            const byName = new Map();
            icons.forEach(item => {
              const el = makeIconEl(item);
              palette.appendChild(el);
              byName.set(item.name, el);
            });

            // Restore placements
            const saved = loadPlacements();
            if (saved) {
              const apply = (arr, container) => (arr || []).forEach(name => {
                const el = byName.get(name); if (el) container.appendChild(el);
              });
              apply(saved.top3, top3);
              apply(saved.high, high);
              apply(saved.mid,  mid);
              apply(saved.low,  low);
              apply(saved.ni,   ni);
            }

            updateTierHeadersAndCaps();
            setupDragAndDrop();

            document.getElementById('fillBtn').addEventListener('click', () => {
              try { generatePrefill(parsed, icons); }
              catch(e){ console.error(e); alertWithContact("Failed to generate prefill URL: " + e.message); }
            });
            document.getElementById('resetBtn').addEventListener('click', resetAllToPalette);

          } catch (e) {
            console.error(e);
            alertWithContact("Failed to decode data: " + e.message);
          }
        }
        proceedWhenLZReady();

      } catch (e) {
        console.error(e);
        alertWithContact("Unexpected error: " + e.message);
      }
    })();
  </script>
</body>
</html>
