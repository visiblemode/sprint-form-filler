<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Sprint Tier Filler</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Dependency per spec -->
  <script src="lz-string.min.js"></script>
  <!-- Optional fallback if local file missing -->
  <script>
    (function ensureLZ(){
      if (!window.LZString) {
        var s = document.createElement('script');
        s.src = "https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js";
        document.head.appendChild(s);
      }
    })();
  </script>
  <style>
    :root{
      /* Pastels on dark (from your spec) */
      --pastel-red:    rgba(255, 107, 129, 0.18);
      --pastel-yellow: rgba(255, 221,  87, 0.18);
      --pastel-green:  rgba( 46, 204, 113, 0.18);
      --pastel-teal:   rgba( 26, 188, 156, 0.18);
      --pastel-grey:   rgba(200, 200, 200, 0.12);

      /* Overcap */
      --overcap-fill:  rgba(220,  53,  69, 0.35); /* firmer red */
      --overcap-border:#dc3545;                   /* strong red */

      --fg: #fff;
      --bg: #000;
      --muted:#aaa;
      --line:#36c26a; /* typing-indicator green for insertion line */
      --dash:#666;    /* default dashed border on dark */
      --chip:#e0e0e0;
    }

    /* Global dark theme + anti-select/drag */
    html, body { height: 100%; background: var(--bg); color: var(--fg); }
    body {
      font-family: system-ui, sans-serif;
      margin: 12px;
      -webkit-user-select: none;
      -moz-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
    }
    * { -webkit-tap-highlight-color: transparent; }
    img, svg { -webkit-user-drag: none; user-drag: none; }

    h2 { margin: 12px 0 6px; font-size: 1rem; color: var(--fg); }
    .app { display: grid; gap: 16px; }

    .tip { color: var(--fg); opacity: 0.9; font-size: 0.95rem; }

    .row { display: grid; gap: 8px; }
    .row-head { display:flex; align-items:baseline; gap:10px; flex-wrap:wrap; }
    .row-head .live { font-weight:600; }
    .row-head .count { font-variant-numeric: tabular-nums; color: var(--fg); }
    .row-head .count.over { color: #ff5252; } /* just the X turns red */

    /* Drop zones */
    .palette, .tier {
      border: 2px dashed var(--dash);
      padding: 8px;
      min-height: 64px;
      display: flex;
      flex-wrap: wrap;
      align-items: flex-start;
      gap: 6px;
      position: relative;
      border-radius: 10px;
      overflow: hidden; /* ensure icons + images respect rounded corners */
    }

    /* Tier pastel backgrounds (on dark) */
    #tier-top3 { background: var(--pastel-red);  }
    #tier-high { background: var(--pastel-yellow);}
    #tier-mid  { background: var(--pastel-green);}
    #tier-low  { background: var(--pastel-teal); }
    #tier-ni   { background: var(--pastel-grey); }

    /* Overcap: firmer red fill + thicker dashed red border */
    .tier.overcap {
      background: var(--overcap-fill) !important;
      border-color: var(--overcap-border);
      border-width: 3px;
      border-style: dashed;
    }

    /* Icons — clipped to rounded corners, prevent image corners peeking */
    .icon {
      width: 56px; height: 56px;
      border: 1px solid #333;
      border-radius: 8px;
      background: #111 center/contain no-repeat;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: grab;
      touch-action: none;
      position: relative;
      overflow: hidden;           /* clip internal image to rounded corners */
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06);
    }
    .icon:active { cursor: grabbing; }
    .icon img {
      width: 100%; height: 100%;
      object-fit: contain;
      pointer-events: none;
      border-radius: inherit;     /* keep image corners matching parent */
      display: block;
    }

    /* Slim green insertion indicator (no box) */
    .ghost-line {
      width: 2px;
      height: 72%;           /* a bit shorter than row for nice look */
      background: var(--line);
      border-radius: 2px;
      align-self: center;
    }

    .controls { display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
    button {
      padding: 8px 12px;
      background: #111;
      color: var(--fg);
      border: 1px solid #333;
      border-radius: 8px;
    }
    button:hover { border-color:#555; }
    .small { font-size: 0.9rem; color: var(--muted); }
  </style>
</head>
<body>
  <div class="app">
    <!-- Top tooltip stays at top -->
    <div class="tip">
      Drag items into tiers. Over-cap rows turn light red. Palette items are treated as Not Interested (not submitted).
    </div>

    <!-- Tiers block with live counters -->
    <section class="row">
      <div class="row-head">
        <h2>Top 3 (<span class="live">Current: <span id="cnt-top3" class="count">0</span>/3</span>)</h2>
      </div>
      <div id="tier-top3" class="tier" data-tier="top3" data-max="3" aria-label="Top 3"></div>
    </section>

    <section class="row">
      <div class="row-head">
        <h2>High (<span class="live">Current: <span id="cnt-high" class="count">0</span>/5</span>)</h2>
      </div>
      <div id="tier-high" class="tier" data-tier="high" data-max="5" aria-label="High"></div>
    </section>

    <section class="row">
      <div class="row-head">
        <h2>Mid (<span class="live">Current: <span id="cnt-mid" class="count">0</span>/10</span>)</h2>
      </div>
      <div id="tier-mid" class="tier" data-tier="mid" data-max="10" aria-label="Mid"></div>
    </section>

    <section class="row">
      <div class="row-head">
        <h2>Low (<span class="live">Current: <span id="cnt-low" class="count">0</span>/15</span>)</h2>
      </div>
      <div id="tier-low" class="tier" data-tier="low" data-max="15" aria-label="Low"></div>
    </section>

    <section class="row">
      <div class="row-head">
        <h2>Not Interested</h2>
      </div>
      <div id="tier-ni" class="tier" data-tier="ni" aria-label="Not Interested"></div>
    </section>

    <!-- Controls + Palette below tiers -->
    <section class="row">
      <div class="controls">
        <button id="fillBtn">Fill Google Form</button>
        <button id="resetBtn" title="Move all items back to the palette">Reset</button>
        <span class="small">Palette is below — items left here are not submitted.</span>
      </div>
      <div class="row-head">
        <h2>Palette</h2>
      </div>
      <div id="palette" class="palette" data-tier="palette" aria-label="Palette"></div>
    </section>
  </div>

  <script>
    // ---------------------------
    // Helpers
    // ---------------------------
    function alertWithContact(msg) {
      alert(msg + "\n\nPlease notify @dovemail on Discord about this error");
    }
    function alertSimple(msg) { alert(msg); } // for overfill only

    function getParam(name) {
      const fromHash = new URLSearchParams((location.hash || "").replace(/^#/, ""));
      if (fromHash.has(name)) return fromHash.get(name);
      const fromQuery = new URLSearchParams(location.search);
      if (fromQuery.has(name)) return fromQuery.get(name);
      return null;
    }

    function convertToIconData(parsed) {
      if (!Array.isArray(parsed.pokemon)) throw new Error("`pokemon` must be an array");
      return parsed.pokemon.map(item => {
        if (!Array.isArray(item) || item.length < 3) {
          throw new Error("Each pokemon item must be [displayName, entryId, imageFile]");
        }
        const [displayName, entryId, imageFile] = item;
        const imgUrl = `https://www.serebii.net/pokemonsleep/pokemon/icon/${imageFile}`;
        return { name: displayName, entryId, imgUrl };
      });
    }

    function findInsertionPoint(container, clientX) {
      const children = Array.from(container.querySelectorAll('.icon'));
      let closest = null, closestOffset = Number.POSITIVE_INFINITY;
      for (const child of children) {
        const rect = child.getBoundingClientRect();
        const mid = rect.left + rect.width / 2;
        const offset = clientX - mid;
        if (offset < 0 && Math.abs(offset) < closestOffset) {
          closestOffset = Math.abs(offset);
          closest = child;
        }
      }
      return closest; // null => append
    }

    function tierElements() {
      return {
        palette: document.getElementById('palette'),
        top3: document.getElementById('tier-top3'),
        high: document.getElementById('tier-high'),
        mid: document.getElementById('tier-mid'),
        low: document.getElementById('tier-low'),
        ni: document.getElementById('tier-ni'),
      };
    }

    function headerSpans() {
      return {
        top3: document.getElementById('cnt-top3'),
        high: document.getElementById('cnt-high'),
        mid:  document.getElementById('cnt-mid'),
        low:  document.getElementById('cnt-low'),
      };
    }

    function updateTierHeadersAndCaps() {
      const tiers = document.querySelectorAll('.tier');
      const hdr = headerSpans();
      tiers.forEach(tier => {
        const cap = tier.dataset.max ? parseInt(tier.dataset.max, 10) : null;
        const count = tier.querySelectorAll('.icon').length;
        if (cap && count > cap) tier.classList.add('overcap'); else tier.classList.remove('overcap');
        const key = tier.dataset.tier;
        if (hdr[key]) {
          hdr[key].textContent = String(count);
          if (cap && count > cap) hdr[key].classList.add('over'); else hdr[key].classList.remove('over');
        }
      });
    }

    function anyTierOverCap() {
      const tiers = document.querySelectorAll('.tier');
      for (const tier of tiers) {
        const cap = tier.dataset.max ? parseInt(tier.dataset.max, 10) : null;
        const count = tier.querySelectorAll('.icon').length;
        if (cap && count > cap) return true;
      }
      return false;
    }

    // ---------------------------
    // Persistence
    // ---------------------------
    const STORAGE_KEY = "stf-placements-v1";
    function savePlacements() {
      const { top3, high, mid, low, ni } = tierElements();
      const getNames = el => Array.from(el.querySelectorAll('.icon')).map(i => i.dataset.id);
      const data = {
        top3: getNames(top3),
        high: getNames(high),
        mid:  getNames(mid),
        low:  getNames(low),
        ni:   getNames(ni),
      };
      try { localStorage.setItem(STORAGE_KEY, JSON.stringify(data)); }
      catch(e){ console.warn("Failed to save placements:", e); }
    }
    function loadPlacements() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return null;
        return JSON.parse(raw);
      } catch(e) {
        console.warn("Failed to load placements:", e);
        return null;
      }
    }
    function clearPlacements() {
      try { localStorage.removeItem(STORAGE_KEY); } catch(e){}
    }

    // ---------------------------
    // Drag & Drop + Touch
    // ---------------------------
    let dragState = { draggingEl: null, originContainer: null, ghostEl: null };

    function ensureGhostLine() {
      if (!dragState.ghostEl) {
        const line = document.createElement('div');
        line.className = 'ghost-line';
        dragState.ghostEl = line;
      }
      return dragState.ghostEl;
    }

    function makeIconEl(item) {
      const el = document.createElement('div');
      el.className = 'icon'; el.draggable = true;
      el.dataset.id = item.name; el.dataset.entryId = item.entryId;
      el.setAttribute('aria-label', item.name);

      const img = document.createElement('img');
      img.alt = item.name; img.src = item.imgUrl; img.draggable = false;
      el.appendChild(img);

      // Desktop DnD
      el.addEventListener('dragstart', (e) => {
        dragState.draggingEl = el;
        dragState.originContainer = el.parentElement;
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData('text/plain', el.dataset.id);
        requestAnimationFrame(() => { el.style.opacity = '0.5'; });
      });
      el.addEventListener('dragend', () => {
        el.style.opacity = '';
        dragState.draggingEl = null; dragState.originContainer = null;
        if (dragState.ghostEl) { dragState.ghostEl.remove(); dragState.ghostEl = null; }
        updateTierHeadersAndCaps(); savePlacements();
      });

      // Touch DnD
      el.addEventListener('touchstart', () => {
        dragState.draggingEl = el;
        dragState.originContainer = el.parentElement;
        el.style.opacity = '0.6';
      }, {passive:true});

      el.addEventListener('touchmove', (e) => {
        const t = e.touches[0];
        const target = document.elementFromPoint(t.clientX, t.clientY);
        const container = target ? target.closest('.tier, .palette') : null;
        if (!container) return;
        const line = ensureGhostLine();
        const before = findInsertionPoint(container, t.clientX);
        if (before) container.insertBefore(line, before);
        else container.appendChild(line);
      }, {passive:false});

      el.addEventListener('touchend', () => {
        el.style.opacity = '';
        const line = dragState.ghostEl;
        if (line && line.parentElement) {
          line.parentElement.insertBefore(el, line);
        }
        if (line) line.remove();
        dragState.ghostEl = null; dragState.draggingEl = null; dragState.originContainer = null;
        updateTierHeadersAndCaps(); savePlacements();
      });

      return el;
    }

    function setupDragAndDrop() {
      const droppables = document.querySelectorAll('.palette, .tier');
      droppables.forEach(container => {
        container.addEventListener('dragover', (e) => {
          e.preventDefault();
          const dragging = dragState.draggingEl; if (!dragging) return;
          const line = ensureGhostLine();
          const before = findInsertionPoint(container, e.clientX);
          if (before) container.insertBefore(line, before);
          else container.appendChild(line);
        });

        container.addEventListener('drop', (e) => {
          e.preventDefault();
          const dragging = dragState.draggingEl; if (!dragging) return;
          const line = dragState.ghostEl;
          if (line && line.parentElement === container) {
            container.insertBefore(dragging, line);
            line.remove(); dragState.ghostEl = null;
          } else {
            container.appendChild(dragging);
          }
          updateTierHeadersAndCaps(); savePlacements();
        });
      });
    }

    // ---------------------------
    // Generation Logic (direct per-tier)
    // ---------------------------
    function generatePrefill(parsed, iconData) {
      if (anyTierOverCap()) {
        alertSimple("One or more rows exceed their maximum. Please adjust before generating.");
        return;
      }

      const { top3: top3El, high: highEl, mid: midEl, low: lowEl } = tierElements();
      const getNames = el => Array.from(el.querySelectorAll('.icon')).map(i => i.dataset.id);

      const top3Names = getNames(top3El);
      const highNames = getNames(highEl);
      const midNames  = getNames(midEl);
      const lowNames  = getNames(lowEl);

      const nameToEntry = new Map(iconData.map(o => [o.name, o.entryId]));

      const params = new URLSearchParams();
      params.set('usp', 'pp_url');

      if (parsed.top1 && top3Names[0]) params.set(`entry.${parsed.top1}`, top3Names[0]);
      if (parsed.top2 && top3Names[1]) params.set(`entry.${parsed.top2}`, top3Names[1]);
      if (parsed.top3 && top3Names[2]) params.set(`entry.${parsed.top3}`, top3Names[2]);

      for (const n of highNames) { const id = nameToEntry.get(n); if (id) params.append(`entry.${id}`, "high (5max)"); }
      for (const n of midNames)  { const id = nameToEntry.get(n); if (id) params.append(`entry.${id}`, "medium (10max)"); }
      for (const n of lowNames)  { const id = nameToEntry.get(n); if (id) params.append(`entry.${id}`, "low (15max)"); }

      const base = parsed.url;
      if (!base) { alertWithContact("Missing form base `url` in data."); return; }
      const theLink = `${base}?${params.toString()}`;
      console.log("Prefill URL:", theLink);
      window.open(theLink, "_blank");
    }

    // ---------------------------
    // Reset
    // ---------------------------
    function resetAllToPalette() {
      const ok = confirm("Reset all placements and move all items back to the palette?");
      if (!ok) return;
      const { palette, top3, high, mid, low, ni } = tierElements();
      const allPlaced = [top3, high, mid, low, ni]
        .flatMap(el => Array.from(el.querySelectorAll('.icon')));
      allPlaced.forEach(icon => palette.appendChild(icon));
      clearPlacements();
      updateTierHeadersAndCaps();
    }

    // ---------------------------
    // Boot
    // ---------------------------
    (function init() {
      try {
        const dataParam = getParam('data');
        if (!dataParam) { alertWithContact("No data parameter found."); return; }

        function proceedWhenLZReady() {
          if (!window.LZString) { setTimeout(proceedWhenLZReady, 20); return; }
          try {
            const json = LZString.decompressFromEncodedURIComponent(dataParam);
            if (!json) throw new Error("Decompression produced empty result");
            const parsed = JSON.parse(json);

            const icons = convertToIconData(parsed);
            const { palette, top3, high, mid, low, ni } = tierElements();

            // Render all icons to palette
            const byName = new Map();
            icons.forEach(item => {
              const el = makeIconEl(item);
              palette.appendChild(el);
              byName.set(item.name, el);
            });

            // Restore placements
            const saved = loadPlacements();
            if (saved) {
              const apply = (arr, container) => (arr || []).forEach(name => {
                const el = byName.get(name); if (el) container.appendChild(el);
              });
              apply(saved.top3, top3);
              apply(saved.high, high);
              apply(saved.mid,  mid);
              apply(saved.low,  low);
              apply(saved.ni,   ni);
            }

            updateTierHeadersAndCaps();
            setupDragAndDrop();

            document.getElementById('fillBtn').addEventListener('click', () => {
              try { generatePrefill(parsed, icons); }
              catch(e){ console.error(e); alertWithContact("Failed to generate prefill URL: " + e.message); }
            });
            document.getElementById('resetBtn').addEventListener('click', resetAllToPalette);

          } catch (e) {
            console.error(e);
            alertWithContact("Failed to decode data: " + e.message);
          }
        }
        proceedWhenLZReady();

      } catch (e) {
        console.error(e);
        alertWithContact("Unexpected error: " + e.message);
      }
    })();
  </script>
</body>
</html>
