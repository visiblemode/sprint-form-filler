<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Sprint Tier Filler</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Dependency per spec -->
  <script src="lz-string.min.js"></script>
  <!-- Optional fallback if local file missing -->
  <script>
    (function ensureLZ(){
      if (!window.LZString) {
        var s = document.createElement('script');
        s.src = "https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js";
        document.head.appendChild(s);
      }
    })();
  </script>
  <style>
    :root{
      /* Pastels on dark */
      --pastel-red:    rgba(255, 107, 129, 0.28);
      --pastel-yellow: rgba(255, 221,  87, 0.28);
      --pastel-green:  rgba( 46, 204, 113, 0.28);
      --pastel-teal:   rgba( 26, 188, 156, 0.28);
      --pastel-grey:   rgba(200, 200, 200, 0.22);

      /* Overcap */
      --overcap-fill:  rgba(220, 53, 69, 0.35); /* firmer red */
      --overcap-border:#dc3545;                  /* strong red */

      /* Neutrals (dark theme) */
      --bg: #000;
      --text: #e9e9e9;
      --muted: #bbb;
      --border: #444;
      --tile-bg: #111;
      --tile-border: #555;
      --ghost-line: #888;
    }

    /* Base */
    html, body { background: var(--bg); color: var(--text); }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 12px; }
    h2 { margin: 12px 0 6px; font-size: 1rem; color: #fff; }
    .app { display: grid; gap: 16px; }

    .tip { color: var(--muted); font-size: 0.95rem; }

    .row { display: grid; gap: 8px; }
    .row-head { display:flex; align-items:baseline; gap:10px; flex-wrap:wrap; }
    .row-head .live { font-weight:600; }
    .row-head .count { font-variant-numeric: tabular-nums; }
    .row-head .count.over { color: var(--overcap-border); } /* just the X turns red */

    /* Containers */
    .palette, .tier {
      border: 1.5px dashed var(--border);
      padding: 8px;
      min-height: 64px;
      display: flex;
      flex-wrap: wrap;
      align-items: flex-start;
      gap: 6px;
      position: relative;
      border-radius: 10px;
      /* ensure inner content respects the rounded corners when backgrounds touch edges */
      overflow: hidden;
      color: #fff; /* white text on tier labels/headers area */
    }

    /* Tier background colors (pastels on dark) */
    #tier-top3 { background: var(--pastel-red); }
    #tier-high { background: var(--pastel-yellow); }
    #tier-mid  { background: var(--pastel-green); }
    #tier-low  { background: var(--pastel-teal); }
    #tier-ni   { background: var(--pastel-grey); }

    /* Palette stays neutral but dark */
    .palette { background: rgba(255,255,255,0.04); }

    /* Overcap visuals */
    .overcap {
      background: var(--overcap-fill) !important;
      border-color: var(--overcap-border) !important;
      border-width: 2.5px !important; /* thicker dashed border */
    }

    /* Icon tiles (rounded & clipped) */
    .icon {
      width: 56px; height: 56px;
      border: 1px solid var(--tile-border);
      border-radius: 10px;
      background: var(--tile-bg) center/contain no-repeat;
      display: inline-flex; align-items: center; justify-content: center;
      cursor: grab; user-select: none; touch-action: none; position: relative;
      overflow: hidden; /* critical: clip image to rounded corners */
    }
    .icon:active { cursor: grabbing; }
    .icon img {
      width: 100%; height: 100%; object-fit: contain; pointer-events: none;
      display: block;
      border-radius: inherit; /* keep image corner rounding consistent */
    }

    /* Drag ghost (visible on dark) */
    .ghost {
      width: 56px; height: 56px;
      outline: 2px solid var(--ghost-line);
      outline-offset: -2px; border-radius: 10px;
      background: repeating-linear-gradient(
        45deg,
        rgba(255,255,255,0.09), rgba(255,255,255,0.09) 6px,
        rgba(255,255,255,0.04) 6px, rgba(255,255,255,0.04) 12px
      );
    }

    .controls { display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
    button {
      padding: 8px 12px; border-radius: 8px; border: 1px solid var(--border);
      background: #111; color: var(--text);
    }
    button:hover { filter: brightness(1.1); }
    .small { font-size: 0.9rem; color: var(--muted); }
  </style>
</head>
<body>
  <div class="app">
    <!-- Tip stays at top -->
    <div class="tip">
      Drag items into tiers. Over-cap rows turn light red. Palette items are treated as Not Interested (not submitted).
    </div>

    <!-- Tiers -->
    <section class="row">
      <div class="row-head">
        <h2>Top 3 (<span class="live">Current: <span id="cnt-top3" class="count">0</span>/3</span>)</h2>
      </div>
      <div id="tier-top3" class="tier" data-tier="top3" data-max="3" aria-label="Top 3"></div>
    </section>

    <section class="row">
      <div class="row-head">
        <h2>High (<span class="live">Current: <span id="cnt-high" class="count">0</span>/5</span>)</h2>
      </div>
      <div id="tier-high" class="tier" data-tier="high" data-max="5" aria-label="High"></div>
    </section>

    <section class="row">
      <div class="row-head">
        <h2>Mid (<span class="live">Current: <span id="cnt-mid" class="count">0</span>/10</span>)</h2>
      </div>
      <div id="tier-mid" class="tier" data-tier="mid" data-max="10" aria-label="Mid"></div>
    </section>

    <section class="row">
      <div class="row-head">
        <h2>Low (<span class="live">Current: <span id="cnt-low" class="count">0</span>/15</span>)</h2>
      </div>
      <div id="tier-low" class="tier" data-tier="low" data-max="15" aria-label="Low"></div>
    </section>

    <section class="row">
      <div class="row-head">
        <h2>Not Interested</h2>
      </div>
      <div id="tier-ni" class="tier" data-tier="ni" aria-label="Not Interested"></div>
    </section>

    <!-- Controls + Palette below tiers -->
    <section class="row">
      <div class="controls">
        <button id="fillBtn">Fill Google Form</button>
        <button id="resetBtn" title="Move all items back to the palette">Reset</button>
        <span class="small">Palette is below â€” items left here are not submitted.</span>
      </div>
      <div class="row-head">
        <h2>Palette</h2>
      </div>
      <div id="palette" class="palette" data-tier="palette" aria-label="Palette"></div>
    </section>
  </div>

  <script>
    // ---------------------------
    // Helpers
    // ---------------------------
    function alertWithContact(msg) {
      alert(msg + "\n\nPlease notify @dovemm on Discord about this error");
    }
    function alertSimple(msg) { alert(msg); } // for overfill only

    function getParam(name) {
      const fromHash = new URLSearchParams((location.hash || "").replace(/^#/, ""));
      if (fromHash.has(name)) return fromHash.get(name);
      const fromQuery = new URLSearchParams(location.search);
      if (fromQuery.has(name)) return fromQuery.get(name);
      return null;
    }

    function convertToIconData(parsed) {
      if (!Array.isArray(parsed.pokemon)) throw new Error("`pokemon` must be an array");
      return parsed.pokemon.map(item => {
        if (!Array.isArray(item) || item.length < 3) {
          throw new Error("Each pokemon item must be [displayName, entryId, imageFile]");
        }
        const [displayName, entryId, imageFile] = item;
        const imgUrl = `https://www.serebii.net/pokemonsleep/pokemon/icon/${imageFile}`;
        return { name: displayName, entryId, imgUrl };
      });
    }

    function findInsertionPoint(container, clientX) {
      const children = Array.from(container.querySelectorAll('.icon'));
      let closest = null, closestOffset = Number.POSITIVE_INFINITY;
      for (const child of children) {
        const rect = child.getBoundingClientRect();
        const mid = rect.left + rect.width / 2;
        const offset = clientX - mid;
        if (offset < 0 && Math.abs(offset) < closestOffset) {
          closestOffset = Math.abs(offset);
          closest = child;
        }
      }
      return closest; // null => append
    }

    function tierElements() {
      return {
        palette: document.getElementById('palette'),
        top3: document.getElementById('tier-top3'),
        high: document.getElementById('tier-high'),
        mid: document.getElementById('tier-mid'),
        low: document.getElementById('tier-low'),
        ni: document.getElementById('tier-ni'),
      };
    }

    function headerSpans() {
      return {
        top3: document.getElementById('cnt-top3'),
        high: document.getElementById('cnt-high'),
        mid:  document.getElementById('cnt-mid'),
        low:  document.getElementById('cnt-low'),
      };
    }

    function updateTierHeadersAndCaps() {
      const tiers = document.querySelectorAll('.tier');
      const hdr = headerSpans();
      tiers.forEach(tier => {
        const cap = tier.dataset.max ? parseInt(tier.dataset.max, 10) : null;
        const count = tier.querySelectorAll('.icon').length;
        if (cap && count > cap) tier.classList.add('overcap'); else tier.classList.remove('overcap');
        const key = tier.dataset.tier;
        if (hdr[key]) {
          hdr[key].textContent = String(count);
          if (cap && count > cap) hdr[key].classList.add('over'); else hdr[key].classList.remove('over');
        }
      });
    }

    function anyTierOverCap() {
      const tiers = document.querySelectorAll('.tier');
      for (const tier of tiers) {
        const cap = tier.dataset.max ? parseInt(tier.dataset.max, 10) : null;
        const count = tier.querySelectorAll('.icon').length;
        if (cap && count > cap) return true;
      }
      return false;
    }

    // ---------------------------
    // Persistence
    // ---------------------------
    const STORAGE_KEY = "stf-placements-v1";
    function savePlacements() {
      const { top3, high, mid, low, ni } = tierElements();
      const getNames = el => Array.from(el.querySelectorAll('.icon')).map(i => i.dataset.id);
      const data = {
        top3: getNames(top3),
        high: getNames(high),
        mid:  getNames(mid),
        low:  getNames(low),
        ni:   getNames(ni),
      };
      try { localStorage.setItem(STORAGE_KEY, JSON.stringify(data)); }
      catch(e){ console.warn("Failed to save placements:", e); }
    }
    function loadPlacements() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return null;
        return JSON.parse(raw);
      } catch(e) {
        console.warn("Failed to load placements:", e);
        return null;
      }
    }
    function clearPlacements() {
      try { localStorage.removeItem(STORAGE_KEY); } catch(e){}
    }

    // ---------------------------
    // Drag & Drop + Touch
    // ---------------------------
    let dragState = { draggingEl: null, originContainer: null, ghostEl: null };

    function makeIconEl(item) {
      const el = document.createElement('div');
      el.className = 'icon'; el.draggable = true;
      el.dataset.id = item.name; el.dataset.entryId = item.entryId;
      el.setAttribute('aria-label', item.name);
      const img = document.createElement('img');
      img.alt = item.name; img.src = item.imgUrl;
      el.appendChild(img);

      // Desktop
      el.addEventListener('dragstart', (e) => {
        dragState.draggingEl = el;
        dragState.originContainer = el.parentElement;
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData('text/plain', el.dataset.id);
        requestAnimationFrame(()=>{ el.style.opacity = '0.5'; });
      });
      el.addEventListener('dragend', () => {
        el.style.opacity = '';
        dragState.draggingEl = null; dragState.originContainer = null;
        if (dragState.ghostEl) { dragState.ghostEl.remove(); dragState.ghostEl = null; }
        updateTierHeadersAndCaps(); savePlacements();
      });

      // Touch
      el.addEventListener('touchstart', () => {
        dragState.draggingEl = el;
        dragState.originContainer = el.parentElement;
        el.style.opacity = '0.6';
      }, {passive:true});
      el.addEventListener('touchmove', (e) => {
        const t = e.touches[0];
        const target = document.elementFromPoint(t.clientX, t.clientY);
        const container = target ? target.closest('.tier, .palette') : null;
        if (!container) return;
        if (!dragState.ghostEl) {
          dragState.ghostEl = document.createElement('div');
          dragState.ghostEl.className = 'ghost';
        }
        const before = findInsertionPoint(container, t.clientX);
        if (before) container.insertBefore(dragState.ghostEl, before);
        else container.appendChild(dragState.ghostEl);
      }, {passive:false});
      el.addEventListener('touchend', () => {
        el.style.opacity = '';
        const ghost = dragState.ghostEl;
        if (ghost && ghost.parentElement) {
          ghost.parentElement.insertBefore(el, ghost);
        }
        if (ghost) ghost.remove();
        dragState.ghostEl = null; dragState.draggingEl = null; dragState.originContainer = null;
        updateTierHeadersAndCaps(); savePlacements();
      });

      return el;
    }

    function setupDragAndDrop() {
      const droppables = document.querySelectorAll('.palette, .tier');
      droppables.forEach(container => {
        container.addEventListener('dragover', (e) => {
          e.preventDefault();
          const dragging = dragState.draggingEl; if (!dragging) return;
          if (!dragState.ghostEl) {
            dragState.ghostEl = document.createElement('div');
            dragState.ghostEl.className = 'ghost';
          }
          const before = findInsertionPoint(container, e.clientX);
          if (before) container.insertBefore(dragState.ghostEl, before);
          else container.appendChild(dragState.ghostEl);
        });
        container.addEventListener('drop', (e) => {
          e.preventDefault();
          const dragging = dragState.draggingEl; if (!dragging) return;
          const ghost = dragState.ghostEl;
          if (ghost && ghost.parentElement === container) {
            container.insertBefore(dragging, ghost);
            ghost.remove(); dragState.ghostEl = null;
          } else {
            container.appendChild(dragging);
          }
          updateTierHeadersAndCaps(); savePlacements();
        });
      });
    }

    // ---------------------------
    // Generation Logic (direct per-tier)
    // ---------------------------
    function generatePrefill(parsed, iconData) {
      if (anyTierOverCap()) {
        alertSimple("One or more rows exceed their maximum. Please adjust before generating.");
        return;
      }
      const { top3: top3El, high: highEl, mid: midEl, low: lowEl } = tierElements();
      const getNames = el => Array.from(el.querySelectorAll('.icon')).map(i => i.dataset.id);

      const top3Names = getNames(top3El);
      const highNames = getNames(highEl);
      const midNames  = getNames(midEl);
      const lowNames  = getNames(lowEl);

      const nameToEntry = new Map(iconData.map(o => [o.name, o.entryId]));
      const params = new URLSearchParams();
      params.set('usp', 'pp_url');

      if (parsed.top1 && top3Names[0]) params.set(`entry.${parsed.top1}`, top3Names[0]);
      if (parsed.top2 && top3Names[1]) params.set(`entry.${parsed.top2}`, top3Names[1]);
      if (parsed.top3 && top3Names[2]) params.set(`entry.${parsed.top3}`, top3Names[2]);

      for (const n of highNames) { const id = nameToEntry.get(n); if (id) params.append(`entry.${id}`, "high (5max)"); }
      for (const n of midNames)  { const id = nameToEntry.get(n); if (id) params.append(`entry.${id}`, "medium (10max)"); }
      for (const n of lowNames)  { const id = nameToEntry.get(n); if (id) params.append(`entry.${id}`, "low (15max)"); }

      const base = parsed.url;
      if (!base) { alertWithContact("Missing form base `url` in data."); return; }
      const theLink = `${base}?${params.toString()}`;
      console.log("Prefill URL:", theLink);
      window.open(theLink, "_blank");
    }

    // ---------------------------
    // Reset
    // ---------------------------
    function resetAllToPalette() {
      const ok = confirm("Reset all placements and move all items back to the palette?");
      if (!ok) return;
      const { palette, top3, high, mid, low, ni } = tierElements();
      const allPlaced = [top3, high, mid, low, ni]
        .flatMap(el => Array.from(el.querySelectorAll('.icon')));
      allPlaced.forEach(icon => palette.appendChild(icon));
      clearPlacements();
      updateTierHeadersAndCaps();
    }

    // ---------------------------
    // Boot
    // ---------------------------
    (function init() {
      try {
        const dataParam = getParam('data');
        if (!dataParam) { alertWithContact("No data parameter found."); return; }

        function proceedWhenLZReady() {
          if (!window.LZString) { setTimeout(proceedWhenLZReady, 20); return; }
          try {
            const json = LZString.decompressFromEncodedURIComponent(dataParam);
            if (!json) throw new Error("Decompression produced empty result");
            const parsed = JSON.parse(json);

            const icons = convertToIconData(parsed);
            const { palette, top3, high, mid, low, ni } = tierElements();

            // Render all icons to palette
            const byName = new Map();
            icons.forEach(item => {
              const el = makeIconEl(item);
              palette.appendChild(el);
              byName.set(item.name, el);
            });

            // Restore placements
            const saved = loadPlacements();
            if (saved) {
              const apply = (arr, container) => (arr || []).forEach(name => {
                const el = byName.get(name); if (el) container.appendChild(el);
              });
              apply(saved.top3, top3);
              apply(saved.high, high);
              apply(saved.mid,  mid);
              apply(saved.low,  low);
              apply(saved.ni,   ni);
            }

            updateTierHeadersAndCaps();
            setupDragAndDrop();

            document.getElementById('fillBtn').addEventListener('click', () => {
              try { generatePrefill(parsed, icons); }
              catch(e){ console.error(e); alertWithContact("Failed to generate prefill URL: " + e.message); }
            });
            document.getElementById('resetBtn').addEventListener('click', resetAllToPalette);

          } catch (e) {
            console.error(e);
            alertWithContact("Failed to decode data: " + e.message);
          }
        }
        proceedWhenLZReady();

      } catch (e) {
        console.error(e);
        alertWithContact("Unexpected error: " + e.message);
      }
    })();
  </script>
</body>
</html>
